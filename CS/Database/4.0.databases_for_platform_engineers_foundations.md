# Databases – A Practical Foundation for Platform & DevOps Engineers

This document explains **why databases exist**, **what problems they solved**, and **how different database types are used in real systems**. It is written for **Platform Engineers / DevOps Engineers**, not DBAs.

---

## 1. Why Databases Were Introduced (Root Cause)

### Before Databases (Manual → Files)

**Manual world**:
- Data stored in record books
- One row per entry (date, amount, name)
- Searching = flipping pages
- No standard way to link records

**Early computer world**:
- Data stored in flat files (text files, CSVs)
- Each application wrote its own logic to:
  - Read files
  - Search content
  - Update records
- No common standard
- Very slow and error‑prone

### Problems with File‑Based Storage

- No fast search
- No relationships between data
- No consistency guarantees
- No concurrent access handling
- Every developer reinvented search logic

### What Databases Solved

Databases introduced:
- **Structured storage** (rows & columns)
- **Indexing** (fast search)
- **Relationships** between data
- **Concurrency control**
- **Consistency & reliability**

Databases are not just storage — they are **data management engines**.

---

## 2. What Type of Data Goes Where

| Data Type | Where It Lives | Why |
|---------|---------------|-----|
| Customer records | Database | Structured, queryable |
| Transactions | Database | Consistency & history |
| Images / videos | Blob / Object storage | Large, unstructured |
| Logs | Object storage / Log systems | Append‑only |
| Frequently used values | Cache (Redis) | Speed |

---

## 3. Relational Databases (SQL)

### What They Are

- Data stored in **tables**
- Fixed schema (columns defined upfront)

Example — strict table schema and evolution:

```sql
-- initial schema
CREATE TABLE customers (
  customer_id   INT PRIMARY KEY,
  name          VARCHAR(100) NOT NULL,
  phone         VARCHAR(15),
  created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- inserting data
INSERT INTO customers (customer_id, name, phone) VALUES (1, 'Ravi', '9876543210');

-- adding a new column requires a schema migration
ALTER TABLE customers ADD COLUMN email VARCHAR(255);

-- changing a column type may require a table rewrite (costly on very large tables)
ALTER TABLE customers ALTER COLUMN phone TYPE VARCHAR(20);
```

Notes:
- Schema must be defined before use; good for data integrity and strong typing.
- Schema changes require migrations and can be disruptive at scale (plan rolling changes, use nullable defaults, or background migrations).
- Works well when structure is stable and strict validation is needed.
- Relationships via **foreign keys**

Example — enforce customer → account relationship:

```sql
CREATE TABLE customers (
  customer_id   SERIAL PRIMARY KEY,
  name          VARCHAR(100) NOT NULL
);

CREATE TABLE accounts (
  account_id    SERIAL PRIMARY KEY,
  customer_id   INT NOT NULL REFERENCES customers(customer_id) ON DELETE RESTRICT,
  balance       NUMERIC(12,2) NOT NULL
);

-- valid insert
INSERT INTO customers (name) VALUES ('Ravi');
INSERT INTO accounts (customer_id, balance) VALUES (1, 15000);

-- referential integrity: inserting an account with a non-existent customer fails
-- INSERT INTO accounts (customer_id, balance) VALUES (999, 100); -- error
```

Notes:
- Foreign keys enforce relationships and prevent orphan rows.
- Use cascade rules (ON DELETE CASCADE / SET NULL / RESTRICT) to control dependent-row behavior.
- Helpful for joins and maintaining data integrity across tables.
- Uses **SQL (Structured Query Language)**

### Example – Banking System

#### Table: Customers

| CustomerID | Name | Phone |
|-----------|------|-------|
| 1 | Ravi | 9876543210 |

#### Table: Accounts

| AccountID | CustomerID | Balance |
|----------|------------|---------|
| 101 | 1 | 15000 |

**Relationship**: `CustomerID`

### Why SQL Databases Exist

- Data integrity (ACID)
- Accurate transactions
- Complex queries
- Strong consistency

### Common Use Cases

- Banking systems
- ERP
- Orders & payments
- Inventory systems

---

## 4. Non‑Relational Databases (NoSQL)

### Why NoSQL Was Introduced

Problems with SQL at scale:
- Rigid schemas
- Hard to scale horizontally
- Too many joins

NoSQL focuses on:
- Flexibility
- Scale
- Speed

---

## 5. Types of NoSQL Databases

### 5.1 Document Databases (MongoDB)

#### Example – Social Media Post

```json
{
  "userId": "123",
  "content": "Good morning!",
  "images": ["img1.jpg"],
  "likes": 120,
  "comments": [
    {"user": "456", "text": "Nice"}
  ]
}
```

**Why**:
- Flexible structure
- Easy to evolve

---

### 5.2 Key‑Value Stores (Redis)

| Key | Value |
|----|------|
| user:123:balance | 15000 |

Used for:
- Caching
- Sessions
- Fast lookups

---

### 5.3 Column Databases (Cassandra)

Used for:
- Massive scale
- Time‑series data
- Write‑heavy workloads

Example:
- Metrics
- Logs
- IoT data

---

### 5.4 Graph Databases

Used for:
- Relationship‑heavy data
- Social networks
- Recommendation engines

Example:
- Friend → Friend → Friend traversal

---

## 6. Redis Cache – Why It Exists

### Problem Before Cache

Every request:
- Application → Database
- Database becomes bottleneck

### What Cache Solves

- Stores **frequently used data in RAM**
- Extremely fast access

### Example Flow

1. App requests balance
2. Check Redis
3. If miss → DB → Redis
4. Next request → Redis

### TTL (Time To Live)

- Data auto‑expires
- Prevents stale data

---

## 7. Cache Consistency Strategies

- Cache‑aside (most common)
- Event‑driven invalidation
- TTL expiration

Production systems **combine all**.

---

## 8. Platform Engineer Responsibilities (Databases)

You are NOT a DBA. You must:

- Provision databases (Terraform)
- Choose managed vs self‑hosted
- Configure backups
- Ensure HA
- Secure access
- Monitor health

---

## 9. Managed Database vs Kubernetes Database

### Managed Database

Use when:
- Cloud available
- High reliability needed
- Low ops overhead

### Kubernetes StatefulSet

Use when:
- On‑prem / Edge
- Full control required
- Hybrid deployments

---

## 10. Edge & On‑Prem Databases

### Why Edge Exists

- Low latency
- Offline operation
- Factory environments

### Why Lightweight Kubernetes

- Limited resources
- No cloud dependency

---

## 11. High Availability Concepts

| Term | Meaning |
|----|--------|
| Primary | Main writer |
| Replica | Read copy |
| Active‑Passive | One active |
| Active‑Active | Multiple active |

---

## 12. Final Mental Model

- Database = source of truth
- Cache = speed layer
- Blob storage = file storage
- SQL = consistency
- NoSQL = scale & flexibility

---

**You now understand databases at a platform‑engineering level.**

Next layers:
- Backup & restore drills
- Disaster recovery
- Cost optimization
- Security audits

