
# From Disk Blocks to SQL  
## Why Filesystems, Databases, and SQL Exist (Explained from First Principles)

This document explains databases **from absolute scratch**, in a way that maps cleanly to
**platform engineering, Kubernetes, and Terraform mental models**.

You should be able to:
- Explain databases to a junior engineer
- Answer *“why SQL?”* in interviews
- Relate SQL to declarative systems like Terraform & Kubernetes

---

## 1. Reality at the Bottom: Disk Blocks

At the lowest level, computers only have **disk blocks**.

```
[Block][Block][Block][Block]
```

Disk blocks:
- Store raw bytes
- Have no names
- Have no structure
- Have no safety guarantees

Humans cannot work directly with disk blocks.

---

## 2. What the Filesystem Solved

The filesystem is an **OS-level abstraction** over disk blocks.

```
file.txt
   |
 inode
   |
[Block 12][Block 45][Block 78]
```

### Filesystem responsibilities
- File & directory names
- Grouping blocks into files
- Persistence across reboots
- Permissions & ownership
- Preventing block corruption

### Filesystem guarantee
> “I will safely store bytes.”

### Filesystem does NOT understand
- Records
- Rows & columns
- Relationships
- Concurrent writers’ intent
- Queries

---

## 3. Filesystem Failure: The Overwrite Problem

File:
```
balance.txt
Ravi=1000
```

Two programs run concurrently:

- Program A: reads 1000 → adds 500 → writes 1500
- Program B: reads 1000 → subtracts 200 → writes 800

Final file content:
```
Ravi=800   ❌
```

Correct answer:
```
Ravi=1300
```

Filesystem stores bytes, not **meaning or intent**.

This is the **first reason databases were invented**.

---

## 4. What a Database Really Is

A database is **a long-running program (process)**.

It:
- Owns data access
- Coordinates writers
- Enforces rules
- Prevents corruption

Architecture shift:

```
Applications → DATABASE PROCESS → Filesystem → Disk
```

Golden rule:
> Applications never touch data files directly.

---

## 5. What Databases Solved

Databases solved **data management**, not querying.

They introduced:

### Centralized access
- Single gatekeeper
- Ordered writes
- No lost updates

### Organized storage
- Tables
- Rows & columns
- Data types

### Relationships
- Reference data instead of duplicating it

### Indexes
- Separate structures for fast lookup

### Crash recovery (WAL)
- Write intent first
- Undo / redo after crash

Databases solved **correctness, safety, and sharing**.

---

## 6. What Databases Did NOT Solve

Even with databases:

- Data existed
- Tables existed
- Indexes existed

But humans still had **no easy way to ask questions**.

To read data, developers had to write **procedural programs**.

---

## 7. Life Without SQL (Procedural Access)

Stored data:

Customers:
```
id | name
1  | Ravi
2  | Amit
```

Orders:
```
order_id | customer_id | amount
101      | 1           | 500
102      | 1           | 300
103      | 2           | 200
```

Question:
> “Show me Ravi’s orders”

### Without SQL, you must write code

```
open customers
loop customers
  if name == "Ravi"
    save id

open orders
loop orders
  if customer_id == saved id
    print order
```

Problems:
- Every question = new program
- Everyone writes logic differently
- Performance tuning is manual
- Code breaks as data grows

This does not scale for humans.

---

## 8. Why a Query Language Was Needed

Humans think in **questions**:
> “What data do I want?”

Computers without a query language force:
> “How do I loop through data?”

A query language exists to:
> Separate **intent** from **execution**.

---

## 9. SQL: Declarative Querying

Same question in SQL:

```sql
SELECT orders.order_id, orders.amount
FROM customers, orders
WHERE customers.id = orders.customer_id
  AND customers.name = 'Ravi';
```

Meaning:
- Describe result
- Database decides steps

Internally:

```
SQL Query
   ↓
Query Planner
   ↓
Execution Plan
   ↓
Data
```

The database:
- Chooses indexes
- Chooses join order
- Adapts as data grows

---

## 10. Indexes + SQL (Important Distinction)

Indexes existed **before** SQL.

Difference:

Without SQL:
- Humans choose indexes manually
- Humans plan loops

With SQL:
- Database chooses indexes
- Database plans execution

Indexes help machines.
SQL helps humans.

---

## 11. SQL Is Declarative (Like Terraform & Kubernetes)

Terraform:
```hcl
resource "aws_instance" "web" {
  count = 3
}
```

Kubernetes:
```yaml
replicas: 3
image: nginx
```

SQL:
```sql
SELECT * FROM orders WHERE customer = 'Ravi';
```

All three:
- Declare desired state/result
- Let the engine figure out execution

---

## 12. Final Mental Model

```
Human Intent
   ↓
SQL (Declarative Language)
   ↓
Database Engine
  - Locks
  - Indexes
  - WAL
  - Relations
   ↓
Filesystem
   ↓
Disk Blocks
```

Each layer solves a **different class of problems**.

---

## 13. One-Sentence Summary (Memorize)

Databases solved safe and shared data storage, while SQL solved the human problem of querying data by providing a declarative, standardized way to express what data is needed without writing procedural code.
