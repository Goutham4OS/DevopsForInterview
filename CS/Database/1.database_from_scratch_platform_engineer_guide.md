
# Databases from Scratch — What, Why, and How (Platform Engineer View)

This document explains **databases from first principles**:
- What a database really is
- Why files were not enough
- How architecture evolved (2-tier → 3-tier)
- What problems databases solve (one by one)
- How relational databases came later
- How everything still ends as bytes on disk

Written for **deep understanding**, not memorization.

---

## 1. What Is a Database?

**Definition**  
A database is **a long-running program (process)** whose job is to **safely manage shared data**.

It is **not just tables** and **not just files**.

**Why the name “Database”?**
- **Data** → information (records, numbers, facts)
- **Base** → one central place

> A database is a *central base where shared data is stored and controlled*.

Key idea:
- Files store bytes
- Databases manage correctness

---

## 2. Before Databases: File-Based Systems

### How early systems worked

Applications directly read and wrote files:

```
App A  ──>  data.txt
App B  ──>  data.txt
```

The filesystem:
- Knows filenames
- Knows bytes
- Does **not** know meaning

Example file:
```
balance.txt
Ravi=1000
```

---

## 3. The Overwrite Problem (Why Files Failed)

Two programs run at the same time:

- Program A: reads 1000 → adds 500 → wants 1500
- Program B: reads 1000 → subtracts 200 → wants 800

Filesystem allows:
```
A writes 1500
B writes 800
```

Final result = **800 (wrong)**  
Correct result = **1300**

Filesystem problem:
- No coordination
- No locking of meaning
- Last writer wins

This is the **first problem databases were created to solve**.

---

## 4. The First Databases: Central Control

### Architectural change

```
Applications  →  DATABASE PROGRAM  →  Files
```

New rule:
> Applications never touch data files directly.

The database:
- Decides write order
- Coordinates access
- Prevents overwrites

This alone solved **shared data corruption**.

---

## 5. Two-Tier vs Three-Tier Architecture

### Two-Tier (Early)

```
Client App  →  Database
```

- Client contains UI + logic
- Database stores data
- Hard to scale

### Three-Tier (Modern)

```
Client (UI)
     ↓
Application Server (Logic)
     ↓
Database (Data)
```

Benefits:
- Better scaling
- Better security
- Clear separation of concerns

---

## 6. Next Problem: Slow Searching

Without databases, searching means **linear scan**.

Example:
```
ID,Name,Dept
1,Ravi,Eng
2,Amit,Sales
3,John,Eng
```

To find Dept = Eng:
- Read row 1
- Read row 2
- Read row 3
- ...
- Read all rows

This becomes impossible at millions of rows.

---

## 7. Database Solution: Indexing

An **index** is a separate data structure used only for searching.

Analogy:
- Book pages = data
- Index page = lookup

Example index:
```
Eng   → Row 1, Row 3
Sales → Row 2
```

Search flow:
```
Query → Index → Exact Rows
```

Important:
- Index ≠ table
- Index costs storage + write time
- Index gives massive read speed

Indexes are usually implemented as **B-Trees** internally.

---

## 8. Crash Recovery Problem

Filesystem behavior:
- Crash during write = corrupted file
- Filesystem does not know intent

Example:
```
balance=1000  → crash during update → balance=15???
```

Data is lost.

---

## 9. Database Solution: Intent Logging (WAL)

Databases change the order of operations:

1. Write intent to log
2. Modify data
3. Mark operation complete

After crash:
- Intent but not complete → UNDO
- Intent complete but data missing → REDO

This guarantees **data consistency after crashes**.

---

## 10. Data Duplication (Excel Problem)

Flat files / spreadsheets repeat data:

```
OrderID | Name | Phone
1       | Ravi | 9999
2       | Ravi | 9999
```

Problems:
- Update one row, forget another
- Data becomes inconsistent

Filesystem cannot prevent this.

---

## 11. Relational Model (Came Later)

The relational model solved duplication by **splitting data by meaning**.

### Example

Customers:
```
CustomerID | Name | Phone
1          | Ravi | 9999
```

Orders:
```
OrderID | CustomerID | Amount
1       | 1          | 500
2       | 1          | 300
```

Benefits:
- Store data once
- Reference everywhere
- Enforced relationships (foreign keys)

This is what made relational databases powerful.

---

## 12. What Does “Tree” Mean in Databases?

### Tree Type 1: Hierarchical Databases (Old)

```
Customer
 └─ Orders
    └─ Items
```

Problems:
- Rigid
- Hard to change
- Replaced by relational model

### Tree Type 2: Index Trees (Modern)

Indexes use **B-Trees** for fast search:

```
        Eng
       /   \
     HR   Sales
```

This tree:
- Is NOT data
- Is only for searching

---

## 13. How Everything Ends as Bytes

On disk, databases store files:

```
Data files   → rows
Index files  → trees
Log files    → intent
```

Filesystem:
- Stores bytes safely

Database:
- Knows how bytes map to meaning

---

## 14. Final Mental Model

```
Applications
     ↓
Database Process
  - Access control
  - Indexing
  - Recovery
  - Relationships
     ↓
Filesystem
     ↓
Disk (Blocks & Bytes)
```

Each layer solves a **different problem**.

---

## 15. One-Sentence Summary

Databases were created to safely manage shared data by centralizing access, preventing overwrites, enabling fast search with indexes, recovering from crashes with logs, and eliminating duplication through the relational model — all while still storing bytes on disk.

![alt text](image-1.png)

![alt text](image-2.png)