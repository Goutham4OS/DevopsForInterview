# How Data Is Read and Written on Disk (Why Blocks Exist)

## Goal
Explain **from first principles** how disks read/write data and **why blocks are unavoidable**, using physics-first reasoning, diagrams, and concrete examples.

---

## 1. Start From Hardware (No OS, No Filesystem)

### What a Disk Physically Is

**HDD (Hard Disk Drive)**
- Spinning metal platters with magnetic coating
- A read/write head floats above the surface
- Data = magnetic orientation of tiny regions

**SSD (Solid State Drive)**
- Flash memory cells holding electrical charge
- No spinning parts
- Still not byte-addressable like RAM

**Key truth**
> Disk hardware cannot precisely access single bytes reliably.

---

## 2. Primitive Read / Write (Before Blocks)

### Writing (Conceptual)

You want to write:
```
10110010
```

Physically:
- Head moves to a location
- Magnetic field or electric charge is applied
- A **region** is affected, not an atom or byte

```
[ Head ]
   ↓
██████████  ← affected region
```

That region is the ancestor of a **block**.

---

## 3. Why Reading a Single Byte Is Impossible

Imagine bytes laid out on disk:

```
| byte 1 | byte 2 | byte 3 |
``>

When reading byte 2:
- Head alignment is imperfect
- Vibration, noise, drift exist
- Neighboring data is sensed anyway

So hardware designers decided:

> “We only guarantee correctness if we read a **whole chunk**.”

That chunk became:
- Sector (512 bytes, old)
- Block (4 KB, modern)

---

## 4. The First Hardware Rule

> **Disks can only read and write fixed-size chunks reliably.**

This is a hardware rule, not a filesystem rule.

---

## 5. What If Blocks Did Not Exist?

### Writing without blocks
- Partial magnetic overwrite
- Neighbor corruption
- No durability guarantees

### Reading without blocks
- No stable boundary
- Checksum impossible
- Data corruption

### Performance
- Millions of tiny I/O ops
- Head never stabilizes
- Extreme latency

Result: ❌ unusable system

---

## 6. Real Read / Write Flow (Modern Systems)

### Write 1 Byte (Reality)

```
Application: write 1 byte
        ↓
OS: request write
        ↓
Disk Controller:
  1. Read full 4 KB block
  2. Modify 1 byte in memory
  3. Write entire 4 KB block back
```

This is called **Read–Modify–Write**.

---

### Read 1 Byte (Reality)

```
Application: read byte 500
        ↓
Disk:
  1. Read entire block containing byte 500
  2. Send block to RAM
OS:
  3. Return only requested byte
```

Reading 1 byte ≈ reading 4 KB.

---

## 7. Why RAM Does NOT Need Blocks

| Property | RAM | Disk |
|--------|-----|------|
| Addressable unit | Byte | Block |
| Access | Direct | Indirect |
| Latency | Nanoseconds | Micro/Milliseconds |
| Precision | Exact | Region-based |

RAM is directly wired to the CPU.
Disk is not.

---

## 8. File vs Block (Critical Distinction)

- **Block**: physical storage unit
- **File**: logical OS abstraction

Example:

```
Block size = 4 KB
File size  = 10 KB

Blocks used:
[4 KB] [4 KB] [4 KB]
``>

Disk used = 12 KB  
Unused space = internal fragmentation

---

## 9. Why 4 KB Is the Sweet Spot

- Too small → massive metadata, slow
- Too large → huge waste for small files

4 KB balances:
- Performance
- Reliability
- Space efficiency

---

## 10. Final Mental Model

```
CPU  →  RAM  →  Disk
byte    byte    block
```

> Blocks exist because **physics does not allow safe, efficient byte-level disk access**.

---

## One-Sentence Summary

A block is the smallest physically reliable unit of disk I/O, forced by hardware limitations, which the OS and filesystems must obey.
