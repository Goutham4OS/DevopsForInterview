
# Linux Processes, Signals, Zombies & OOM
## A DevOps / Platform Engineer Deep-Dive (Docker & Kubernetes Context)

This document explains **Linux process fundamentals** from first principles and connects them directly to **Docker and Kubernetes behavior**.

Focus areas:
- Program vs Process
- Parent, Child, Siblings
- Process Groups
- Signals (SIGTERM, SIGKILL, SIGCHLD)
- Zombie Processes
- wait() and reaping
- PID 1 responsibilities
- OOM Killer
- Why containers and pods die the way they do

---

## 1. Program vs Process (Foundation)

### Program
- A file on disk
- Contains instructions
- Not running
- Uses no CPU or memory

Examples:
```
/usr/bin/python
/usr/bin/nginx
```

### Process
- A running instance of a program
- Loaded into memory
- Scheduled on CPU
- Identified by a PID

One program file can produce **many processes**.

---

## 2. Parent, Child, and Sibling Processes

A process can create another process using `fork()`.

Example:
```
Parent
 ├── Child A
 └── Child B
```

- Child A and Child B are **siblings**
- Same parent
- Different PIDs
- Independent execution

This model is used by:
- nginx (master → workers)
- shells
- application servers

---

## 3. Process Groups (Signal Control)

A **process group** is a logical grouping of processes so signals can be sent together.

Example:
```
Shell (PGID 1000)
 └── demo.sh
     ├── sleep
     └── grep
```

Pressing `Ctrl+C`:
- Sends `SIGINT` to the **entire process group**

Process groups are not the same as parent/child relationships.

---

## 4. Signals – What They Really Are

A **signal** is a lightweight notification sent by the kernel to a process.

### Must-know signals

| Signal | Meaning |
|-----|-----|
| SIGTERM | Graceful shutdown request |
| SIGKILL | Immediate termination |
| SIGINT | Ctrl+C |
| SIGCHLD | Child process exited |
| SIGHUP | Reload configuration |

---

## 5. Signal Flow (Diagram)

```
User / Kernel
     |
     |  SIGTERM
     v
  Process
     |
     |-- cleanup
     |-- close files
     |-- exit
```

If the process does not handle the signal:
- Kernel applies default action (usually terminate)

---

## 6. Signal Handling (Bash Example)

```bash
#!/bin/bash

trap 'echo "SIGTERM received, cleaning up"; exit 0' SIGTERM

echo "Running as PID $$"
sleep 100
```

This allows **graceful shutdown**.

---

## 7. SIGTERM vs SIGKILL

### SIGTERM
- Polite request
- Can be handled
- Used by:
  - systemd
  - Docker
  - Kubernetes

### SIGKILL
- Cannot be handled
- Kernel kills immediately
- No cleanup
- Used as last resort

Rule:
> Always try SIGTERM first.

---

## 8. Zombie Processes (Critical Concept)

### What is a Zombie?

A zombie is:
- A process that has finished execution
- But whose parent has NOT collected its exit status

State:
```
Z
```

Zombies:
- Use no CPU
- Use no memory
- DO consume PID table entries

---

## 9. Why Zombies Exist

When a child exits:
- Kernel frees resources
- Keeps a small record (PID + exit code)
- Waits for parent to ask: “How did you exit?”

That question is asked via `wait()`.

---

## 10. How `wait()` Cleans Zombies

Flow:
```
Child exits
 → Kernel marks zombie
 → Parent calls wait()
 → Kernel gives exit code
 → Zombie entry deleted
```

### Bash Example (Zombie)

```bash
sleep 1 &
sleep 100
```

### Bash Example (No Zombie)

```bash
sleep 1 &
wait
sleep 100
```

One `wait` makes the difference.

---

## 11. PID 1 – Why It Is Special

PID 1:
- First process
- Ancestor of all processes
- Must:
  - Handle signals
  - Reap orphaned children

On a server:
```
PID 1 = systemd
```

In a container:
```
PID 1 = your app (often)
```

Most apps are **not designed** to be PID 1.

---

## 12. Zombies in Containers (Very Important)

In containers:
- Your app runs as PID 1
- If it doesn’t call wait():
  - zombies accumulate
  - container becomes unhealthy

This is why tools exist:
- tini
- dumb-init

They exist only to:
- forward signals
- reap children

---

## 13. OOM Killer (Out Of Memory)

When system or cgroup runs out of memory:

Kernel:
- Selects a victim process
- Sends `SIGKILL`
- Process dies immediately

Important:
- SIGKILL cannot be handled
- No cleanup
- Data may be lost

---

## 14. OOM in Containers & Kubernetes

In Kubernetes:
- Memory limit enforced via cgroups
- If container exceeds limit:
  - Kernel triggers OOM
  - Pod gets `OOMKilled`
  - Restart depends on policy

No SIGTERM.
No grace.
Just death.

---

## 15. Combined Lifecycle (Diagram)

```
SIGTERM → cleanup → exit → wait() → process removed
        (healthy)

OOM / SIGKILL → immediate death → no cleanup
```

---

## 16. Why Platform Engineers Must Know This

Because:
- Broken signal handling → stuck pods
- Missing wait() → zombie leaks
- Wrong PID 1 → container instability
- OOM behavior → unexpected restarts

Most production “mysteries” come from misunderstanding this layer.

---

## 17. Final Lock-In Summary

> Linux runs processes, not applications.  
> Signals are how the kernel communicates.  
> Zombies exist when parents don’t wait.  
> PID 1 must reap children.  
> OOM kills without mercy.

---

End of document.
